// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `build_search_candidates`, `calculate_match_score`, `deobfuscate_video_url`, `extract_channel_name`, `extract_core_name`, `extract_episode_number_from_text`, `generic_search_and_play_internal`, `get_cache_file_path`, `load_from_cache`, `load_playback_source_config`, `parse_chinese_number`, `preprocess_search_term`, `save_to_cache`, `search_single_source_with_channels`, `search_single_source_with_progress`, `search_single_source`, `select_episode_by_number`, `try_extract_player_aaaa_url`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ExportedMediaSourceDataList`, `MatchVideo`, `MediaSource`, `SEASON_RE`, `SampleRoot`, `SearchConfig`, `SelectorChannelFormatFlattened`, `SelectorChannelFormatNoChannel`, `SelectorSubjectFormatA`, `SelectorSubjectFormatIndexed`, `SourceArguments`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `deref`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `initialize`

/// 从订阅地址刷新播放源配置并保存到本地缓存
Future<String> refreshPlaybackSourceConfig() =>
    RustLib.instance.api.crateApiGenericScraperRefreshPlaybackSourceConfig();

/// 预加载播放源配置（应用启动时调用）
/// 尝试从本地缓存加载配置，如果缓存不存在则从订阅地址拉取
Future<void> preloadPlaybackSources() =>
    RustLib.instance.api.crateApiGenericScraperPreloadPlaybackSources();

/// 获取所有播放源的状态
Future<List<SourceState>> getPlaybackSources() =>
    RustLib.instance.api.crateApiGenericScraperGetPlaybackSources();

/// 更新单个源的配置
Future<void> updateSingleSourceConfig({required SourceConfigUpdate update}) =>
    RustLib.instance.api.crateApiGenericScraperUpdateSingleSourceConfig(
      update: update,
    );

/// 添加新的源配置
Future<void> addSourceConfig({required SourceConfigUpdate newConfig}) => RustLib
    .instance
    .api
    .crateApiGenericScraperAddSourceConfig(newConfig: newConfig);

/// 搜索所有源，返回所有找到的播放页面URL列表
/// Flutter 端可以使用 WebView 加载这些 URL 来拦截视频请求
///
/// # 参数
/// * `anime_name` - 动画名称
/// * `absolute_episode` - 绝对集号（如第15集），优先匹配
/// * `relative_episode` - 相对集号（如当季第3集），绝对集号找不到时回退使用
Future<List<SearchPlayResult>> genericSearchPlayPages({
  required String animeName,
  int? absoluteEpisode,
  int? relativeEpisode,
}) => RustLib.instance.api.crateApiGenericScraperGenericSearchPlayPages(
  animeName: animeName,
  absoluteEpisode: absoluteEpisode,
  relativeEpisode: relativeEpisode,
);

/// 搜索所有源，以流的形式返回结果（每个源搜索完成后立即返回）
/// 这样可以让UI实时显示搜索结果，而不是等所有源都搜索完毕
Stream<SearchPlayResult> genericSearchPlayPagesStream({
  required String animeName,
  int? absoluteEpisode,
  int? relativeEpisode,
}) => RustLib.instance.api.crateApiGenericScraperGenericSearchPlayPagesStream(
  animeName: animeName,
  absoluteEpisode: absoluteEpisode,
  relativeEpisode: relativeEpisode,
);

/// 获取所有已启用源的列表（用于初始化UI显示）
Future<List<String>> getEnabledSourceNames() =>
    RustLib.instance.api.crateApiGenericScraperGetEnabledSourceNames();

/// 搜索所有源，以流的形式返回详细进度（包含搜索步骤和错误信息）
Stream<SourceSearchProgress> genericSearchWithProgress({
  required String animeName,
  int? absoluteEpisode,
  int? relativeEpisode,
}) => RustLib.instance.api.crateApiGenericScraperGenericSearchWithProgress(
  animeName: animeName,
  absoluteEpisode: absoluteEpisode,
  relativeEpisode: relativeEpisode,
);

/// 搜索并播放动画（支持集号选择）
///
/// # 参数
/// * `anime_name` - 动画名称
/// * `absolute_episode` - 绝对集号（如第15集），优先匹配
/// * `relative_episode` - 相对集号（如当季第3集），绝对集号找不到时回退使用
Future<String> genericSearchAndPlayWithEpisode({
  required String animeName,
  int? absoluteEpisode,
  int? relativeEpisode,
}) =>
    RustLib.instance.api.crateApiGenericScraperGenericSearchAndPlayWithEpisode(
      animeName: animeName,
      absoluteEpisode: absoluteEpisode,
      relativeEpisode: relativeEpisode,
    );

/// 搜索并播放动画（默认第一集，保持向后兼容）
Future<String> genericSearchAndPlay({required String animeName}) => RustLib
    .instance
    .api
    .crateApiGenericScraperGenericSearchAndPlay(animeName: animeName);

/// 搜索所有源，返回包含多channel信息的完整结果
/// 此API用于UI展示所有可用的线路和剧集供用户选择
Future<List<SearchResultWithChannels>> genericSearchWithChannels({
  required String animeName,
}) => RustLib.instance.api.crateApiGenericScraperGenericSearchWithChannels(
  animeName: animeName,
);

/// 搜索所有源，以流的形式返回包含多channel信息的结果
Stream<SearchResultWithChannels> genericSearchWithChannelsStream({
  required String animeName,
}) =>
    RustLib.instance.api.crateApiGenericScraperGenericSearchWithChannelsStream(
      animeName: animeName,
    );

/// 根据指定的channel和集号获取播放页面URL
/// 此API用于在用户选择了具体的线路和集数后获取播放页面
Future<SearchPlayResult> getEpisodePlayUrl({
  required String sourceName,
  required String animeName,
  required BigInt channelIndex,
  int? episodeNumber,
}) => RustLib.instance.api.crateApiGenericScraperGetEpisodePlayUrl(
  sourceName: sourceName,
  animeName: animeName,
  channelIndex: channelIndex,
  episodeNumber: episodeNumber,
);

/// Channel（线路）信息
class ChannelInfo {
  /// Channel 名称（如"线路A"、"简中"、"繁中"等）
  final String name;

  /// Channel 索引
  final BigInt index;

  const ChannelInfo({required this.name, required this.index});

  @override
  int get hashCode => name.hashCode ^ index.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          index == other.index;
}

/// 剧集信息
class EpisodeInfo {
  /// 剧集名称/标题
  final String name;

  /// 剧集URL
  final String url;

  /// 剧集号（如果能解析出来）
  final int? episodeNumber;

  /// 所属channel索引
  final BigInt channelIndex;

  const EpisodeInfo({
    required this.name,
    required this.url,
    this.episodeNumber,
    required this.channelIndex,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      url.hashCode ^
      episodeNumber.hashCode ^
      channelIndex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EpisodeInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          url == other.url &&
          episodeNumber == other.episodeNumber &&
          channelIndex == other.channelIndex;
}

/// 搜索结果：包含播放页面URL和视频URL匹配正则
class SearchPlayResult {
  /// 源名称
  final String sourceName;

  /// 播放页面 URL
  final String playPageUrl;

  /// 用于匹配视频URL的正则表达式
  final String videoRegex;

  /// 直接解析得到的视频URL（如果有）
  final String? directVideoUrl;

  /// 播放所需的 Cookie
  final String? cookies;

  /// 播放所需的 Headers (Referer, User-Agent etc)
  final Map<String, String>? headers;

  /// Channel 名称（如果有多channel）
  final String? channelName;

  /// Channel 索引
  final BigInt? channelIndex;

  const SearchPlayResult({
    required this.sourceName,
    required this.playPageUrl,
    required this.videoRegex,
    this.directVideoUrl,
    this.cookies,
    this.headers,
    this.channelName,
    this.channelIndex,
  });

  @override
  int get hashCode =>
      sourceName.hashCode ^
      playPageUrl.hashCode ^
      videoRegex.hashCode ^
      directVideoUrl.hashCode ^
      cookies.hashCode ^
      headers.hashCode ^
      channelName.hashCode ^
      channelIndex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SearchPlayResult &&
          runtimeType == other.runtimeType &&
          sourceName == other.sourceName &&
          playPageUrl == other.playPageUrl &&
          videoRegex == other.videoRegex &&
          directVideoUrl == other.directVideoUrl &&
          cookies == other.cookies &&
          headers == other.headers &&
          channelName == other.channelName &&
          channelIndex == other.channelIndex;
}

/// 包含多channel信息的搜索结果
class SearchResultWithChannels {
  /// 源名称
  final String sourceName;

  /// 动画详情页URL
  final String detailUrl;

  /// 匹配到的动画名称
  final String matchedTitle;

  /// 所有可用的channels（线路）
  final List<ChannelInfo> channels;

  /// 所有剧集列表（按channel分组）
  final List<EpisodeInfo> episodes;

  /// 用于匹配视频URL的正则表达式
  final String videoRegex;

  /// 播放所需的 Cookie
  final String? cookies;

  /// 播放所需的 Headers
  final Map<String, String>? headers;

  /// 默认字幕语言
  final String? defaultSubtitleLanguage;

  /// 默认分辨率
  final String? defaultResolution;

  const SearchResultWithChannels({
    required this.sourceName,
    required this.detailUrl,
    required this.matchedTitle,
    required this.channels,
    required this.episodes,
    required this.videoRegex,
    this.cookies,
    this.headers,
    this.defaultSubtitleLanguage,
    this.defaultResolution,
  });

  @override
  int get hashCode =>
      sourceName.hashCode ^
      detailUrl.hashCode ^
      matchedTitle.hashCode ^
      channels.hashCode ^
      episodes.hashCode ^
      videoRegex.hashCode ^
      cookies.hashCode ^
      headers.hashCode ^
      defaultSubtitleLanguage.hashCode ^
      defaultResolution.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SearchResultWithChannels &&
          runtimeType == other.runtimeType &&
          sourceName == other.sourceName &&
          detailUrl == other.detailUrl &&
          matchedTitle == other.matchedTitle &&
          channels == other.channels &&
          episodes == other.episodes &&
          videoRegex == other.videoRegex &&
          cookies == other.cookies &&
          headers == other.headers &&
          defaultSubtitleLanguage == other.defaultSubtitleLanguage &&
          defaultResolution == other.defaultResolution;
}

/// 搜索进度状态
enum SearchStep {
  /// 等待中
  pending,

  /// 正在搜索
  searching,

  /// 正在获取详情页
  fetchingDetail,

  /// 正在获取剧集列表
  fetchingEpisodes,

  /// 正在提取视频URL
  extractingVideo,

  /// 搜索成功
  success,

  /// 搜索失败
  failed,
}

class SourceConfigUpdate {
  final String name;
  final String? newName;
  final int? tier;
  final String? defaultSubtitleLanguage;
  final String? defaultResolution;
  final String? searchUrl;
  final String? iconUrl;
  final String? description;
  final String? searchConfigJson;

  const SourceConfigUpdate({
    required this.name,
    this.newName,
    this.tier,
    this.defaultSubtitleLanguage,
    this.defaultResolution,
    this.searchUrl,
    this.iconUrl,
    this.description,
    this.searchConfigJson,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      newName.hashCode ^
      tier.hashCode ^
      defaultSubtitleLanguage.hashCode ^
      defaultResolution.hashCode ^
      searchUrl.hashCode ^
      iconUrl.hashCode ^
      description.hashCode ^
      searchConfigJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceConfigUpdate &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          newName == other.newName &&
          tier == other.tier &&
          defaultSubtitleLanguage == other.defaultSubtitleLanguage &&
          defaultResolution == other.defaultResolution &&
          searchUrl == other.searchUrl &&
          iconUrl == other.iconUrl &&
          description == other.description &&
          searchConfigJson == other.searchConfigJson;
}

/// 带状态的搜索进度
class SourceSearchProgress {
  /// 源名称
  final String sourceName;

  /// 当前搜索步骤
  final SearchStep step;

  /// 错误信息（如果有）
  final String? error;

  /// 播放页面 URL（如果找到）
  final String? playPageUrl;

  /// 用于匹配视频URL的正则表达式
  final String? videoRegex;

  /// 直接解析得到的视频URL（如果有）
  final String? directVideoUrl;

  /// 播放所需的 Cookie
  final String? cookies;

  /// 播放所需的 Headers
  final Map<String, String>? headers;

  /// Channel 名称（如果有多channel）
  final String? channelName;

  /// Channel 索引
  final BigInt? channelIndex;

  /// 所有可用的channels（搜索成功时填充）
  final List<ChannelInfo>? allChannels;

  const SourceSearchProgress({
    required this.sourceName,
    required this.step,
    this.error,
    this.playPageUrl,
    this.videoRegex,
    this.directVideoUrl,
    this.cookies,
    this.headers,
    this.channelName,
    this.channelIndex,
    this.allChannels,
  });

  @override
  int get hashCode =>
      sourceName.hashCode ^
      step.hashCode ^
      error.hashCode ^
      playPageUrl.hashCode ^
      videoRegex.hashCode ^
      directVideoUrl.hashCode ^
      cookies.hashCode ^
      headers.hashCode ^
      channelName.hashCode ^
      channelIndex.hashCode ^
      allChannels.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceSearchProgress &&
          runtimeType == other.runtimeType &&
          sourceName == other.sourceName &&
          step == other.step &&
          error == other.error &&
          playPageUrl == other.playPageUrl &&
          videoRegex == other.videoRegex &&
          directVideoUrl == other.directVideoUrl &&
          cookies == other.cookies &&
          headers == other.headers &&
          channelName == other.channelName &&
          channelIndex == other.channelIndex &&
          allChannels == other.allChannels;
}

class SourceState {
  final String name;
  final String description;
  final String iconUrl;
  final int tier;
  final String defaultSubtitleLanguage;
  final String defaultResolution;
  final String searchUrl;
  final String searchConfigJson;
  final bool enabled;

  const SourceState({
    required this.name,
    required this.description,
    required this.iconUrl,
    required this.tier,
    required this.defaultSubtitleLanguage,
    required this.defaultResolution,
    required this.searchUrl,
    required this.searchConfigJson,
    required this.enabled,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      description.hashCode ^
      iconUrl.hashCode ^
      tier.hashCode ^
      defaultSubtitleLanguage.hashCode ^
      defaultResolution.hashCode ^
      searchUrl.hashCode ^
      searchConfigJson.hashCode ^
      enabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceState &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          description == other.description &&
          iconUrl == other.iconUrl &&
          tier == other.tier &&
          defaultSubtitleLanguage == other.defaultSubtitleLanguage &&
          defaultResolution == other.defaultResolution &&
          searchUrl == other.searchUrl &&
          searchConfigJson == other.searchConfigJson &&
          enabled == other.enabled;
}
