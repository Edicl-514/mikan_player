// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `fetch_extra_bangumi_subjects`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

Future<List<ArchiveQuarter>> fetchArchiveList() =>
    RustLib.instance.api.crateApiCrawlerFetchArchiveList();

Future<List<AnimeInfo>> fetchScheduleBasic({required String yearQuarter}) =>
    RustLib.instance.api.crateApiCrawlerFetchScheduleBasic(
      yearQuarter: yearQuarter,
    );

Future<List<AnimeInfo>> fillAnimeDetails({required List<AnimeInfo> animes}) =>
    RustLib.instance.api.crateApiCrawlerFillAnimeDetails(animes: animes);

Future<List<AnimeInfo>> fetchExtraSubjects({
  required String yearQuarter,
  required List<String> existingIds,
}) => RustLib.instance.api.crateApiCrawlerFetchExtraSubjects(
  yearQuarter: yearQuarter,
  existingIds: existingIds,
);

class AnimeInfo {
  final String title;
  final String? subTitle;
  final String? bangumiId;
  final String? mikanId;
  final String? coverUrl;
  final String? siteUrl;
  final String? broadcastDay;
  final String? broadcastTime;
  final double? score;
  final int? rank;
  final List<String> tags;
  final String? fullJson;

  const AnimeInfo({
    required this.title,
    this.subTitle,
    this.bangumiId,
    this.mikanId,
    this.coverUrl,
    this.siteUrl,
    this.broadcastDay,
    this.broadcastTime,
    this.score,
    this.rank,
    required this.tags,
    this.fullJson,
  });

  @override
  int get hashCode =>
      title.hashCode ^
      subTitle.hashCode ^
      bangumiId.hashCode ^
      mikanId.hashCode ^
      coverUrl.hashCode ^
      siteUrl.hashCode ^
      broadcastDay.hashCode ^
      broadcastTime.hashCode ^
      score.hashCode ^
      rank.hashCode ^
      tags.hashCode ^
      fullJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AnimeInfo &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          subTitle == other.subTitle &&
          bangumiId == other.bangumiId &&
          mikanId == other.mikanId &&
          coverUrl == other.coverUrl &&
          siteUrl == other.siteUrl &&
          broadcastDay == other.broadcastDay &&
          broadcastTime == other.broadcastTime &&
          score == other.score &&
          rank == other.rank &&
          tags == other.tags &&
          fullJson == other.fullJson;
}

class ArchiveQuarter {
  final String year;
  final String quarter;
  final String title;

  const ArchiveQuarter({
    required this.year,
    required this.quarter,
    required this.title,
  });

  @override
  int get hashCode => year.hashCode ^ quarter.hashCode ^ title.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ArchiveQuarter &&
          runtimeType == other.runtimeType &&
          year == other.year &&
          quarter == other.quarter &&
          title == other.title;
}
