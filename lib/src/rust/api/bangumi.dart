// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Fetch episodes for a subject
/// API: GET https://api.bgm.tv/v0/episodes?subject_id={subject_id}&limit=100&offset=0
Future<List<BangumiEpisode>> fetchBangumiEpisodes({
  required PlatformInt64 subjectId,
}) => RustLib.instance.api.crateApiBangumiFetchBangumiEpisodes(
  subjectId: subjectId,
);

/// Fetch characters for a subject
/// API: GET https://api.bgm.tv/v0/subjects/{subject_id}/characters
Future<List<BangumiCharacter>> fetchBangumiCharacters({
  required PlatformInt64 subjectId,
}) => RustLib.instance.api.crateApiBangumiFetchBangumiCharacters(
  subjectId: subjectId,
);

/// Fetch related subjects for a subject
/// API: GET https://api.bgm.tv/v0/subjects/{subject_id}/subjects
/// Only returns anime-related subjects (type 2) with specific relations
Future<List<BangumiRelatedSubject>> fetchBangumiRelations({
  required PlatformInt64 subjectId,
}) => RustLib.instance.api.crateApiBangumiFetchBangumiRelations(
  subjectId: subjectId,
);

/// Scrape comments from the Bangumi website
/// URL: https://bgm.tv/subject/{subject_id}/comments?page={page}
Future<List<BangumiComment>> fetchBangumiComments({
  required PlatformInt64 subjectId,
  required int page,
}) => RustLib.instance.api.crateApiBangumiFetchBangumiComments(
  subjectId: subjectId,
  page: page,
);

/// Scrape episode comments from Bangumi
/// URL: https://bangumi.tv/ep/{episode_id}
Future<List<BangumiEpisodeComment>> fetchBangumiEpisodeComments({
  required PlatformInt64 episodeId,
}) => RustLib.instance.api.crateApiBangumiFetchBangumiEpisodeComments(
  episodeId: episodeId,
);

class BangumiActor {
  final PlatformInt64 id;
  final String name;

  const BangumiActor({required this.id, required this.name});

  @override
  int get hashCode => id.hashCode ^ name.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BangumiActor &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name;
}

class BangumiCharacter {
  final PlatformInt64 id;
  final String name;
  final String roleName;
  final BangumiImages? images;
  final List<BangumiActor> actors;

  const BangumiCharacter({
    required this.id,
    required this.name,
    required this.roleName,
    this.images,
    required this.actors,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      roleName.hashCode ^
      images.hashCode ^
      actors.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BangumiCharacter &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          roleName == other.roleName &&
          images == other.images &&
          actors == other.actors;
}

class BangumiComment {
  final String userName;
  final int? rate;
  final String content;
  final String contentHtml;
  final String time;
  final String avatar;

  const BangumiComment({
    required this.userName,
    this.rate,
    required this.content,
    required this.contentHtml,
    required this.time,
    required this.avatar,
  });

  @override
  int get hashCode =>
      userName.hashCode ^
      rate.hashCode ^
      content.hashCode ^
      contentHtml.hashCode ^
      time.hashCode ^
      avatar.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BangumiComment &&
          runtimeType == other.runtimeType &&
          userName == other.userName &&
          rate == other.rate &&
          content == other.content &&
          contentHtml == other.contentHtml &&
          time == other.time &&
          avatar == other.avatar;
}

class BangumiEpisode {
  final PlatformInt64 id;
  final String name;
  final String nameCn;
  final String description;
  final String airdate;
  final String duration;
  final double sort;

  const BangumiEpisode({
    required this.id,
    required this.name,
    required this.nameCn,
    required this.description,
    required this.airdate,
    required this.duration,
    required this.sort,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      nameCn.hashCode ^
      description.hashCode ^
      airdate.hashCode ^
      duration.hashCode ^
      sort.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BangumiEpisode &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          nameCn == other.nameCn &&
          description == other.description &&
          airdate == other.airdate &&
          duration == other.duration &&
          sort == other.sort;
}

class BangumiEpisodeComment {
  final PlatformInt64 id;
  final String userName;
  final String userId;
  final String avatar;
  final String time;
  final String contentHtml;
  final List<BangumiEpisodeComment> replies;

  const BangumiEpisodeComment({
    required this.id,
    required this.userName,
    required this.userId,
    required this.avatar,
    required this.time,
    required this.contentHtml,
    required this.replies,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      userName.hashCode ^
      userId.hashCode ^
      avatar.hashCode ^
      time.hashCode ^
      contentHtml.hashCode ^
      replies.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BangumiEpisodeComment &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          userName == other.userName &&
          userId == other.userId &&
          avatar == other.avatar &&
          time == other.time &&
          contentHtml == other.contentHtml &&
          replies == other.replies;
}

class BangumiImages {
  final String small;
  final String grid;
  final String large;
  final String medium;
  final String common;

  const BangumiImages({
    required this.small,
    required this.grid,
    required this.large,
    required this.medium,
    required this.common,
  });

  @override
  int get hashCode =>
      small.hashCode ^
      grid.hashCode ^
      large.hashCode ^
      medium.hashCode ^
      common.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BangumiImages &&
          runtimeType == other.runtimeType &&
          small == other.small &&
          grid == other.grid &&
          large == other.large &&
          medium == other.medium &&
          common == other.common;
}

class BangumiRelatedSubject {
  final PlatformInt64 id;
  final String name;
  final String nameCn;
  final String relation;
  final String image;

  const BangumiRelatedSubject({
    required this.id,
    required this.name,
    required this.nameCn,
    required this.relation,
    required this.image,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      nameCn.hashCode ^
      relation.hashCode ^
      image.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BangumiRelatedSubject &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          nameCn == other.nameCn &&
          relation == other.relation &&
          image == other.image;
}
